input = '../server/Msgs.cs'
output = '../client/types.js'

typemappings = {
  'int': 'number',
  'double': 'number',
  'string': 'string',
  'Player': 'string',
  'List<string>': 'string[]'
}

msgs = {}
currec = None
curfields = []
linenum = 0

import re, subprocess, sys, os, traceback

def bad(msg : str):
  print(msg, file=sys.stderr)
  subprocess.Popen("paplay /usr/share/sounds/freedesktop/stereo/service-logout.oga", shell=True)
  exit(1)

def good(msg : str):
  print(msg)
  subprocess.Popen("paplay /usr/share/sounds/freedesktop/stereo/complete.oga", shell=True)

try:
  with open(input) as f:
    for lin in f.readlines():
      linenum += 1
      toks = lin.split()
      if currec is None:
        if len(toks) > 2 and toks[0] == 'record' and toks[2] == '(':
          currec = toks[1]
          curfields = []
          msgs[currec] = curfields
          if currec == 'Msg':
            currec = None
      else: # processing currec
        if len(toks) == 0:
          continue
        if toks[0][0] == '/':
          continue
        if toks[0] == 'record':
          bad(f'Encounterred record on line {linenum} before finding end of record {currec}')
        if toks[0][0] == ')':
          currec = None
          continue
        else:
          if len(toks) < 2:
            bad(f'Expected at least two tokens on line {linenum}')
          fieldNameMatch = re.match(r'^[a-zA-Z0-9_]*', toks[1])
          if fieldNameMatch is None:
            bad(f'Expected a field name on line {linenum} (but found none)')
            exit(1)
          fieldName = fieldNameMatch.group()
          fieldType = toks[0]
          if fieldType not in typemappings:
            bad(f'Unknown type "{fieldType}" on line {linenum}')
          curfields.append("{" + typemappings[fieldType] + "} " + fieldName)

  if currec is not None:
    bad(f'Encountered end of file without finding end of {currec}')

  with open(output, 'w') as f:
    f.write('// autogenerated\n\n/**\n\n')
    for m in msgs:
      f.write(f'@typedef {m}\n')
      for fld in msgs[m]:
        f.write(f' @property {fld}\n')
      f.write(' @property {string} _mt\n')
      f.write('\n')
    f.write('*/\n')

  good(f"Successfully wrote {os.path.abspath(output)}")

except Exception as e:
  traceback.print_exc()
  bad("(Exception encounterred)")

